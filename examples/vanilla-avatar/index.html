<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AnimaSync ‚Äî V2 Avatar: Direct Blendshape Prediction</title>
  <script type="importmap">
  { "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.179.1/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.179.1/examples/jsm/",
    "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3.4.5/lib/three-vrm.module.min.js",
    "@pixiv/three-vrm-animation": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm-animation@3.4.5/lib/three-vrm-animation.module.min.js"
  }}
  </script>
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.17.0/dist/ort.min.js"></script>
  <style>
    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background: #0f0f1a; color: #e2e8f0; min-height: 100vh;
      display: flex; flex-direction: column;
    }

    /* ‚îÄ‚îÄ Header ‚îÄ‚îÄ */
    header {
      display: flex; align-items: center; gap: 12px; flex-wrap: wrap;
      padding: 16px 24px; border-bottom: 1px solid rgba(255,255,255,0.06);
    }
    header h1 { font-size: 1.15rem; font-weight: 700; }
    header h1 span { color: #4cc9f0; }
    .badge {
      padding: 3px 10px; border-radius: 20px; font-size: 0.7rem; font-weight: 600;
      background: rgba(16,185,129,0.12); color: #10b981;
    }
    .badge-ready { background: rgba(16,185,129,0.12); color: #10b981; }
    .badge-loading { background: rgba(245,158,11,0.12); color: #f59e0b; }
    .badge-error { background: rgba(239,68,68,0.12); color: #ef4444; }
    .header-right { margin-left: auto; display: flex; gap: 8px; align-items: center; }

    /* ‚îÄ‚îÄ Layout ‚îÄ‚îÄ */
    .layout { display: flex; flex: 1; overflow: hidden; }
    .panel-left { flex: 1; position: relative; min-width: 0; }
    .panel-right {
      width: 340px; flex-shrink: 0; overflow-y: auto;
      border-left: 1px solid rgba(255,255,255,0.06); padding: 20px;
    }
    @media (max-width: 900px) {
      .layout { flex-direction: column; }
      .panel-right { width: 100%; border-left: none; border-top: 1px solid rgba(255,255,255,0.06); max-height: 40vh; }
    }

    /* ‚îÄ‚îÄ Canvas ‚îÄ‚îÄ */
    #canvas { width: 100%; height: 100%; display: block; }

    /* ‚îÄ‚îÄ VRM Drop overlay ‚îÄ‚îÄ */
    .vrm-overlay {
      position: absolute; inset: 0; display: flex; flex-direction: column;
      align-items: center; justify-content: center; gap: 12px;
      background: rgba(15,15,26,0.92); z-index: 10;
    }
    .vrm-overlay.hidden { display: none; }
    .vrm-overlay p { color: #64748b; font-size: 0.9rem; }
    .vrm-overlay strong { color: #94a3b8; }
    .vrm-overlay .hint { font-size: 0.75rem; color: #475569; max-width: 340px; text-align: center; line-height: 1.5; }
    .vrm-overlay .hint a { color: #4cc9f0; text-decoration: none; }

    /* ‚îÄ‚îÄ Controls ‚îÄ‚îÄ */
    .section-title { font-size: 0.8rem; color: #64748b; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 10px; margin-top: 20px; }
    .section-title:first-child { margin-top: 0; }

    .controls { display: flex; flex-direction: column; gap: 8px; }
    .controls button, .controls label {
      display: flex; align-items: center; gap: 8px;
      padding: 10px 14px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.06);
      background: #16213e; color: #e2e8f0; font-size: 0.85rem;
      cursor: pointer; transition: all 0.15s;
    }
    .controls button:hover { border-color: rgba(76,201,240,0.3); background: #1a2744; }
    .controls button:disabled { opacity: 0.3; cursor: not-allowed; }
    .controls button.active { border-color: #4cc9f0; background: rgba(76,201,240,0.08); }
    .icon { font-size: 1.1rem; }

    /* ‚îÄ‚îÄ Metrics ‚îÄ‚îÄ */
    .metrics-row { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-top: 12px; }
    .metric-box { text-align: center; padding: 10px; background: rgba(255,255,255,0.02); border-radius: 8px; }
    .metric-box .val { font-size: 1.1rem; font-weight: 700; color: #4cc9f0; }
    .metric-box .lbl { font-size: 0.65rem; color: #475569; margin-top: 2px; }

    /* ‚îÄ‚îÄ Blendshape mini bars ‚îÄ‚îÄ */
    .bs-mini { display: flex; flex-direction: column; gap: 3px; }
    .bm-row { display: flex; align-items: center; gap: 6px; }
    .bm-name { width: 80px; font-size: 0.65rem; font-family: monospace; color: #475569; text-align: right; }
    .bm-track { flex: 1; height: 10px; background: rgba(255,255,255,0.03); border-radius: 3px; overflow: hidden; }
    .bm-fill { height: 100%; border-radius: 3px; width: 0%; transition: width 0.04s linear; }
    .bm-fill.jaw { background: #4cc9f0; } .bm-fill.mouth { background: #7c3aed; }
    .bm-fill.eye { background: #10b981; } .bm-fill.brow { background: #f59e0b; }

    /* ‚îÄ‚îÄ Progress ‚îÄ‚îÄ */
    .init-progress { margin-top: 12px; display: none; }
    .init-progress.active { display: block; }
    .init-bar { height: 4px; background: rgba(255,255,255,0.06); border-radius: 2px; overflow: hidden; }
    .init-bar-fill { height: 100%; background: linear-gradient(90deg,#4cc9f0,#7c3aed); width: 0%; transition: width 0.3s; }
    .init-label { font-size: 0.7rem; color: #475569; margin-top: 4px; }

    /* ‚îÄ‚îÄ Footer ‚îÄ‚îÄ */
    footer {
      padding: 12px 24px; text-align: center; font-size: 0.7rem; color: #1e293b;
      border-top: 1px solid rgba(255,255,255,0.04);
    }
    footer a { color: #4cc9f0; text-decoration: none; }
  </style>
</head>
<body>

<header>
  <h1>Anima<span>Sync</span></h1>
  <div class="badge badge-loading" id="badge">Loading...</div>
  <div class="header-right">
    <span style="font-size:0.75rem;color:#475569">V2 (52-dim)</span>
  </div>
</header>

<div class="layout">
  <!-- Left: 3D Canvas -->
  <div class="panel-left">
    <canvas id="canvas"></canvas>
    <div class="vrm-overlay" id="vrm-overlay">
      <p><strong>Drop a .vrm file here</strong></p>
      <p>or use any VRM-compatible avatar</p>
      <div class="hint">
        Free avatars at
        <a href="https://hub.vroid.com/en/models?characterization=allow" target="_blank">VRoid Hub (CC0)</a>
      </div>
    </div>
  </div>

  <!-- Right: Controls & Visualization -->
  <div class="panel-right">
    <div class="section-title">Audio Input</div>
    <div class="controls">
      <label>
        <span class="icon">üìÅ</span> Audio File
        <input type="file" id="audio-input" accept="audio/*" style="display:none">
      </label>
      <button id="mic-btn" disabled><span class="icon">üé§</span> Microphone</button>
    </div>

    <div class="init-progress" id="init-progress">
      <div class="init-bar"><div class="init-bar-fill" id="init-fill"></div></div>
      <div class="init-label" id="init-label">Initializing...</div>
    </div>

    <div class="section-title">Performance</div>
    <div class="metrics-row">
      <div class="metric-box"><div class="val" id="m-frames">‚Äî</div><div class="lbl">Frames</div></div>
      <div class="metric-box"><div class="val" id="m-wasm">‚Äî</div><div class="lbl">WASM</div></div>
      <div class="metric-box"><div class="val" id="m-rtf">‚Äî</div><div class="lbl">RT Factor</div></div>
    </div>

    <div class="section-title">Blendshapes</div>
    <div class="bs-mini" id="bs-mini"></div>
  </div>
</div>

<footer>
  <a href="https://github.com/goodganglabs/AnimaSync">AnimaSync</a> ‚Äî powered by
  <a href="https://www.npmjs.com/package/@goodganglabs/lipsync-wasm-v2">@goodganglabs/lipsync-wasm-v2</a>
</footer>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { VRMLoaderPlugin } from '@pixiv/three-vrm';
import { VRMAnimationLoaderPlugin, createVRMAnimationClip } from '@pixiv/three-vrm-animation';

// ================================================================
// Config
// ================================================================
const VERSION = '0.3.9';
const CDN = `https://cdn.jsdelivr.net/npm/@goodganglabs/lipsync-wasm-v2@${VERSION}`;

const KEY_CHANNELS = [
  { idx: 24, name: 'jawOpen', g: 'jaw' },
  { idx: 31, name: 'mouthFunnel', g: 'mouth' },
  { idx: 37, name: 'mouthPucker', g: 'mouth' },
  { idx: 33, name: 'mouthLwrDnL', g: 'mouth' },
  { idx: 34, name: 'mouthLwrDnR', g: 'mouth' },
  { idx: 43, name: 'mouthSmileL', g: 'mouth' },
  { idx: 44, name: 'mouthSmileR', g: 'mouth' },
  { idx: 39, name: 'mouthRollLw', g: 'mouth' },
  { idx: 40, name: 'mouthRollUp', g: 'mouth' },
  { idx: 8,  name: 'eyeBlinkL', g: 'eye' },
  { idx: 9,  name: 'eyeBlinkR', g: 'eye' },
  { idx: 2,  name: 'browInnerUp', g: 'brow' },
];

const ARKIT_NAMES = [
  'browDownLeft','browDownRight','browInnerUp','browOuterUpLeft','browOuterUpRight',
  'cheekPuff','cheekSquintLeft','cheekSquintRight',
  'eyeBlinkLeft','eyeBlinkRight','eyeLookDownLeft','eyeLookDownRight',
  'eyeLookInLeft','eyeLookInRight','eyeLookOutLeft','eyeLookOutRight',
  'eyeLookUpLeft','eyeLookUpRight','eyeSquintLeft','eyeSquintRight',
  'eyeWideLeft','eyeWideRight',
  'jawForward','jawLeft','jawOpen','jawRight',
  'mouthClose','mouthDimpleLeft','mouthDimpleRight','mouthFrownLeft','mouthFrownRight',
  'mouthFunnel','mouthLeft','mouthLowerDownLeft','mouthLowerDownRight',
  'mouthPressLeft','mouthPressRight','mouthPucker','mouthRight',
  'mouthRollLower','mouthRollUpper','mouthShrugLower','mouthShrugUpper',
  'mouthSmileLeft','mouthSmileRight','mouthStretchLeft','mouthStretchRight',
  'mouthUpperUpLeft','mouthUpperUpRight',
  'noseSneerLeft','noseSneerRight','tongueOut',
];

// ================================================================
// DOM
// ================================================================
const badge = document.getElementById('badge');
const canvas = document.getElementById('canvas');
const vrmOverlay = document.getElementById('vrm-overlay');
const audioInput = document.getElementById('audio-input');
const micBtn = document.getElementById('mic-btn');
const initProgress = document.getElementById('init-progress');
const initFill = document.getElementById('init-fill');
const initLabel = document.getElementById('init-label');
const bsMini = document.getElementById('bs-mini');

// Build blendshape bars
const barRefs = KEY_CHANNELS.map(ch => {
  const row = document.createElement('div'); row.className = 'bm-row';
  row.innerHTML = `<div class="bm-name">${ch.name}</div><div class="bm-track"><div class="bm-fill ${ch.g}" id="bm-${ch.idx}"></div></div>`;
  bsMini.appendChild(row);
  return { idx: ch.idx, fill: null };
});
barRefs.forEach(r => r.fill = document.getElementById(`bm-${r.idx}`));

function updateBars(frame) {
  for (const r of barRefs) {
    r.fill.style.width = Math.min((frame[r.idx] || 0) * 100, 100) + '%';
  }
}

// ================================================================
// Three.js Scene
// ================================================================
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.outputColorSpace = THREE.SRGBColorSpace;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0f0f1a);
const camera = new THREE.PerspectiveCamera(30, 1, 0.1, 100);
camera.position.set(0, 1.25, 1.5);

const controls = new OrbitControls(camera, canvas);
controls.target.set(0, 1.25, 0);
controls.enableDamping = true;
controls.minDistance = 0.3;
controls.maxDistance = 5;
controls.update();

scene.add(new THREE.DirectionalLight(0xffffff, 1.0));
scene.add(new THREE.AmbientLight(0xffffff, 0.6));

function resize() {
  const w = canvas.parentElement.clientWidth;
  const h = canvas.parentElement.clientHeight;
  renderer.setSize(w, h);
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
}
new ResizeObserver(resize).observe(canvas.parentElement);
resize();

// ================================================================
// VRM + VRMA Bone Animation
// ================================================================
const gltfLoader = new GLTFLoader();
gltfLoader.register(p => new VRMLoaderPlugin(p));
gltfLoader.register(p => new VRMAnimationLoaderPlugin(p));

let vrm = null;
let mixer = null;
let idleAction = null;
let speakingAction = null;
let isSpeaking = false;
let crossFadeProgress = 0;

async function loadVRM(url) {
  const gltf = await gltfLoader.loadAsync(url);
  if (vrm) scene.remove(vrm.scene);
  vrm = gltf.userData.vrm;
  scene.add(vrm.scene);
  vrm.scene.rotation.y = Math.PI;

  mixer = new THREE.AnimationMixer(vrm.scene);

  // Load idle + speaking VRMA from WASM embedded bytes
  try {
    const vrmaBytes = lipsync.getVrmaBytes();
    if (vrmaBytes?.idle?.length) {
      const idleGltf = await loadVRMAFromBytes(vrmaBytes.idle);
      const idleAnim = idleGltf.userData.vrmAnimations?.[0];
      if (idleAnim) {
        idleAction = mixer.clipAction(createVRMAnimationClip(idleAnim, vrm));
        idleAction.play();
      }
    }
    if (vrmaBytes?.speaking?.length) {
      const speakGltf = await loadVRMAFromBytes(vrmaBytes.speaking);
      const speakAnim = speakGltf.userData.vrmAnimations?.[0];
      if (speakAnim) {
        speakingAction = mixer.clipAction(createVRMAnimationClip(speakAnim, vrm));
        speakingAction.play();
        speakingAction.setEffectiveWeight(0);
      }
    }
  } catch (e) { console.warn('VRMA load skipped:', e.message); }

  vrmOverlay.classList.add('hidden');
}

async function loadVRMAFromBytes(bytes) {
  const blob = new Blob([bytes], { type: 'application/octet-stream' });
  const url = URL.createObjectURL(blob);
  const gltf = await gltfLoader.loadAsync(url);
  URL.revokeObjectURL(url);
  return gltf;
}

function transitionToSpeaking(instant) {
  isSpeaking = true;
  if (instant) crossFadeProgress = 1;
}
function transitionToIdle() { isSpeaking = false; }

function updateBoneWeights(delta) {
  const speed = 3.0;
  if (isSpeaking && crossFadeProgress < 1) {
    crossFadeProgress = Math.min(1, crossFadeProgress + delta * speed);
  } else if (!isSpeaking && crossFadeProgress > 0) {
    crossFadeProgress = Math.max(0, crossFadeProgress - delta * speed);
  }
  const t = crossFadeProgress;
  const w = t * t * (3 - 2 * t); // smoothstep
  if (idleAction) idleAction.setEffectiveWeight(1 - w);
  if (speakingAction) speakingAction.setEffectiveWeight(w);
}

// VRM drag-and-drop
const panelLeft = document.querySelector('.panel-left');
panelLeft.addEventListener('dragover', e => { e.preventDefault(); vrmOverlay.classList.remove('hidden'); });
panelLeft.addEventListener('dragleave', e => { if (!panelLeft.contains(e.relatedTarget) && vrm) vrmOverlay.classList.add('hidden'); });
panelLeft.addEventListener('drop', async e => {
  e.preventDefault();
  const file = [...e.dataTransfer.files].find(f => f.name.endsWith('.vrm'));
  if (file) await loadVRM(URL.createObjectURL(file));
});

// ================================================================
// LipSync Init
// ================================================================
let lipsync = null;
const frameQueue = [];

async function initLipSync() {
  const { LipSyncWasmWrapper } = await import(`${CDN}/lipsync-wasm-wrapper.js`);
  lipsync = new LipSyncWasmWrapper({ wasmPath: `${CDN}/lipsync_wasm_v2.js` });

  initProgress.classList.add('active');
  await lipsync.init({
    onProgress: (stage, pct) => {
      initFill.style.width = pct + '%';
      initLabel.textContent = `${stage} ‚Äî ${pct}%`;
    },
  });
  initProgress.classList.remove('active');

  badge.textContent = 'Ready';
  badge.className = 'badge badge-ready';
  micBtn.disabled = false;
}

initLipSync().catch(err => {
  badge.textContent = 'Error';
  badge.className = 'badge badge-error';
  initLabel.textContent = err.message;
  console.error(err);
});

// ================================================================
// Apply blendshapes to VRM
// ================================================================
function applyFrame(frame) {
  if (!vrm) return;
  if (vrm.expressionManager) {
    for (let i = 0; i < Math.min(frame.length, ARKIT_NAMES.length); i++) {
      vrm.expressionManager.setValue(ARKIT_NAMES[i], frame[i]);
    }
  } else if (vrm.blendShapeProxy) {
    for (let i = 0; i < Math.min(frame.length, ARKIT_NAMES.length); i++) {
      vrm.blendShapeProxy.setValue(ARKIT_NAMES[i], frame[i]);
    }
    vrm.blendShapeProxy.update();
  }
  updateBars(frame);
}

function resetAvatar() {
  if (!vrm?.expressionManager) return;
  for (const name of ARKIT_NAMES) vrm.expressionManager.setValue(name, 0);
}

// ================================================================
// Audio File Processing
// ================================================================
audioInput.addEventListener('change', async e => {
  const file = e.target.files[0];
  if (!file || !lipsync?.ready) return;

  badge.textContent = 'Processing...';
  badge.className = 'badge badge-loading';

  const t0 = performance.now();
  const result = await lipsync.processFile(file);
  const elapsed = performance.now() - t0;
  const duration = result.frame_count / result.fps;

  document.getElementById('m-frames').textContent = result.frame_count;
  document.getElementById('m-wasm').textContent = (elapsed / 1000).toFixed(2) + 's';
  document.getElementById('m-rtf').textContent = (elapsed / 1000 / duration).toFixed(2) + 'x';

  // Queue all frames
  frameQueue.length = 0;
  for (let i = 0; i < result.frame_count; i++) {
    frameQueue.push(lipsync.getFrame(result, i));
  }

  badge.textContent = `${result.frame_count} frames`;
  badge.className = 'badge badge-ready';

  // Transition to speaking pose
  transitionToSpeaking(true);

  // Play audio in sync
  const audioCtx = new AudioContext();
  const arrayBuf = await file.arrayBuffer();
  const audioBuf = await audioCtx.decodeAudioData(arrayBuf);
  const source = audioCtx.createBufferSource();
  source.buffer = audioBuf;
  source.connect(audioCtx.destination);
  source.start();
  source.onended = () => {
    transitionToIdle();
    resetAvatar();
  };
});

// ================================================================
// Microphone Streaming
// ================================================================
let micActive = false;
let audioContext = null;
let workletNode = null;

micBtn.addEventListener('click', async () => {
  if (micActive) {
    if (workletNode) { workletNode.disconnect(); workletNode = null; }
    if (audioContext) { audioContext.close(); audioContext = null; }
    micActive = false;
    micBtn.classList.remove('active');
    micBtn.innerHTML = '<span class="icon">üé§</span> Microphone';
    transitionToIdle();
    lipsync.reset();
    return;
  }

  if (!lipsync?.ready) return;

  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    audioContext = new AudioContext({ sampleRate: 16000 });
    const source = audioContext.createMediaStreamSource(stream);

    const processorCode = `
      class PCMCapture extends AudioWorkletProcessor {
        constructor() { super(); this._buf = []; }
        process(inputs) {
          const ch = inputs[0]?.[0];
          if (ch) {
            for (let i = 0; i < ch.length; i++) this._buf.push(ch[i]);
            if (this._buf.length >= 1600) {
              this.port.postMessage(new Float32Array(this._buf.splice(0, 1600)));
            }
          }
          return true;
        }
      }
      registerProcessor('pcm-capture', PCMCapture);
    `;
    const blob = new Blob([processorCode], { type: 'application/javascript' });
    const blobUrl = URL.createObjectURL(blob);
    await audioContext.audioWorklet.addModule(blobUrl);
    URL.revokeObjectURL(blobUrl);

    workletNode = new AudioWorkletNode(audioContext, 'pcm-capture');
    source.connect(workletNode);

    transitionToSpeaking(true);

    workletNode.port.onmessage = async e => {
      const result = await lipsync.processAudioChunk(e.data);
      if (result) {
        for (let i = 0; i < result.frame_count; i++) {
          frameQueue.push(lipsync.getFrame(result, i));
        }
        document.getElementById('m-frames').textContent = result.frame_count;
      }
    };

    micActive = true;
    micBtn.classList.add('active');
    micBtn.innerHTML = '<span class="icon">‚èπÔ∏è</span> Stop Mic';
  } catch (err) {
    console.error('Mic error:', err);
    alert('Could not access microphone: ' + err.message);
  }
});

// ================================================================
// Render Loop (30fps frame queue consumption)
// ================================================================
const clock = new THREE.Clock();
let lastFrameTime = 0;
const FRAME_INTERVAL = 1 / 30;

function render() {
  requestAnimationFrame(render);
  const delta = clock.getDelta();

  lastFrameTime += delta;
  if (lastFrameTime >= FRAME_INTERVAL && frameQueue.length > 0) {
    applyFrame(frameQueue.shift());
    lastFrameTime = 0;
  }

  updateBoneWeights(delta);

  if (vrm) vrm.update(delta);
  if (mixer) mixer.update(delta);
  controls.update();
  renderer.render(scene, camera);
}
render();
</script>
</body>
</html>
