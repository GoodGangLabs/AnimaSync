<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Step-by-Step Guide ‚Äî Build Your Own AI Talking Avatar | AnimaSync</title>
  <meta name="description" content="Learn how to build a voice-driven 3D talking avatar step by step. Download a VRM, initialize AnimaSync, and apply real-time lip sync ‚Äî all in the browser.">
  <meta name="theme-color" content="#0f0f1a">

  <!-- Open Graph -->
  <meta property="og:site_name" content="AnimaSync">
  <meta property="og:title" content="Step-by-Step Guide ‚Äî Build Your Own AI Talking Avatar">
  <meta property="og:description" content="6-step interactive guide: download a VRM avatar, initialize AnimaSync V1, load into Three.js, and apply real-time lip sync entirely in the browser.">
  <meta property="og:type" content="article">
  <meta property="og:url" content="https://animasync.quasar.ggls.dev/examples/guide/">
  <meta property="og:image" content="https://animasync.quasar.ggls.dev/assets/readme/hero-banner.svg">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Build Your Own AI Talking Avatar ‚Äî AnimaSync Guide">
  <meta name="twitter:description" content="6-step interactive tutorial: VRM avatar + AnimaSync V1 lip sync engine. Try it live in the browser.">
  <meta name="twitter:image" content="https://animasync.quasar.ggls.dev/assets/readme/hero-banner.svg">

  <meta name="robots" content="index, follow">
  <link rel="canonical" href="https://animasync.quasar.ggls.dev/examples/guide/">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üéôÔ∏è</text></svg>">

  <!-- Structured Data: HowTo -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "HowTo",
    "name": "Build Your Own AI Talking Avatar with AnimaSync",
    "description": "A step-by-step guide to creating a voice-driven 3D talking avatar in the browser using AnimaSync V1, Three.js, and VRM avatars.",
    "totalTime": "PT15M",
    "tool": [
      { "@type": "HowToTool", "name": "AnimaSync V1 (lipsync-wasm-v1)" },
      { "@type": "HowToTool", "name": "Three.js" },
      { "@type": "HowToTool", "name": "@pixiv/three-vrm" },
      { "@type": "HowToTool", "name": "ONNX Runtime Web" }
    ],
    "supply": [
      { "@type": "HowToSupply", "name": "VRM avatar file (.vrm)" },
      { "@type": "HowToSupply", "name": "Audio file or microphone" }
    ],
    "step": [
      {
        "@type": "HowToStep",
        "position": 1,
        "name": "Get a VRM Avatar",
        "text": "Download a free VRM avatar from VRoid Hub. Choose one with 'Allow' characterization for use in your project."
      },
      {
        "@type": "HowToStep",
        "position": 2,
        "name": "Set Up the Project",
        "text": "Add the required dependencies via CDN import map or npm: three, @pixiv/three-vrm, onnxruntime-web, and @goodganglabs/lipsync-wasm-v1."
      },
      {
        "@type": "HowToStep",
        "position": 3,
        "name": "Initialize AnimaSync",
        "text": "Create a LipSyncWasmWrapper instance and call init() to load the WASM module and ONNX model."
      },
      {
        "@type": "HowToStep",
        "position": 4,
        "name": "Load VRM into Three.js",
        "text": "Create a Three.js scene with WebGLRenderer, PerspectiveCamera, and OrbitControls, then load the VRM avatar using GLTFLoader with VRMLoaderPlugin."
      },
      {
        "@type": "HowToStep",
        "position": 5,
        "name": "Apply Lip Sync",
        "text": "Process an audio file with lipsync.processFile(), extract frames with getFrame(), and apply 52 ARKit blendshape values to the VRM expressionManager in a render loop."
      },
      {
        "@type": "HowToStep",
        "position": 6,
        "name": "Add Real-time Microphone Streaming",
        "text": "Use AudioWorklet to capture microphone input at 16kHz and feed chunks to processAudioChunk() for real-time lip sync."
      }
    ],
    "author": {
      "@type": "Organization",
      "name": "GoodGang Labs",
      "url": "https://goodganglabs.com"
    }
  }
  </script>

  <script type="importmap">
  { "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.179.1/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.179.1/examples/jsm/",
    "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3.4.5/lib/three-vrm.module.min.js",
    "@pixiv/three-vrm-animation": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm-animation@3.4.5/lib/three-vrm-animation.module.min.js"
  }}
  </script>
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.17.0/dist/ort.min.js"
          integrity="sha384-FxbnmKChPhtBGG96uaN4fWx3uGOFsz/LPujNUj7BsgaeYq2Z43RcMzM2+w8K+zzM"
          crossorigin="anonymous"></script>

  <style>
    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background: #0f0f1a; color: #e2e8f0; min-height: 100vh;
      line-height: 1.6;
    }

    /* ‚îÄ‚îÄ Header ‚îÄ‚îÄ */
    .guide-header {
      padding: 48px 24px 40px;
      text-align: center;
      border-bottom: 1px solid rgba(255,255,255,0.06);
    }
    .guide-header .back-link {
      display: inline-flex; align-items: center; gap: 6px;
      color: #4cc9f0; text-decoration: none; font-size: 0.8rem; font-weight: 600;
      margin-bottom: 20px;
    }
    .guide-header .back-link:hover { text-decoration: underline; }
    .guide-header h1 {
      font-size: 2rem; font-weight: 800; letter-spacing: -0.03em;
      max-width: 600px; margin: 0 auto;
    }
    .guide-header h1 span { color: #4cc9f0; }
    .guide-header .lead {
      color: #64748b; font-size: 0.95rem; margin-top: 12px;
      max-width: 520px; margin-left: auto; margin-right: auto;
    }
    .guide-header .time-badge {
      display: inline-block; margin-top: 16px; padding: 4px 14px;
      border-radius: 20px; font-size: 0.75rem; font-weight: 600;
      background: rgba(76,201,240,0.08); color: #4cc9f0;
      border: 1px solid rgba(76,201,240,0.15);
    }

    /* ‚îÄ‚îÄ Timeline container ‚îÄ‚îÄ */
    .timeline {
      max-width: 820px; margin: 0 auto; padding: 40px 24px 60px;
    }

    /* ‚îÄ‚îÄ Step ‚îÄ‚îÄ */
    .step {
      display: grid; grid-template-columns: 48px 1fr; gap: 0 24px;
      position: relative;
    }

    /* Vertical line */
    .step:not(:last-child)::before {
      content: '';
      position: absolute;
      left: 23px; top: 48px; bottom: 0;
      width: 2px;
      background: rgba(76,201,240,0.12);
    }

    /* Number circle */
    .step-num {
      width: 48px; height: 48px; border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      font-size: 1.1rem; font-weight: 800;
      background: rgba(76,201,240,0.1); color: #4cc9f0;
      border: 2px solid rgba(76,201,240,0.25);
      position: relative; z-index: 1;
      flex-shrink: 0;
    }
    .step.completed .step-num {
      background: rgba(16,185,129,0.15); color: #10b981;
      border-color: rgba(16,185,129,0.3);
    }
    .step.completed .step-num::after {
      content: '‚úì'; position: absolute; inset: 0;
      display: flex; align-items: center; justify-content: center;
      font-size: 1.2rem; font-weight: 700;
    }
    .step.completed .step-num > span { visibility: hidden; }

    /* Completed step vertical line turns green */
    .step.completed:not(:last-child)::before {
      background: rgba(16,185,129,0.3);
    }

    /* Completed title gets subtle green accent */
    .step.completed .step-title::after {
      content: ' ‚Äî done'; font-size: 0.7rem; font-weight: 600;
      color: #10b981; opacity: 0.7; margin-left: 8px;
    }

    .step-body {
      padding-bottom: 48px;
    }
    .step:last-child .step-body {
      padding-bottom: 0;
    }
    .step-title {
      font-size: 1.15rem; font-weight: 700; margin-bottom: 8px;
      padding-top: 10px;
    }
    .step-desc {
      color: #94a3b8; font-size: 0.88rem; line-height: 1.7;
      margin-bottom: 16px;
    }
    .step-desc a { color: #4cc9f0; text-decoration: none; }
    .step-desc a:hover { text-decoration: underline; }

    /* ‚îÄ‚îÄ Code wrapper (label + toolbar + block) ‚îÄ‚îÄ */
    .code-wrap {
      margin-bottom: 16px; border-radius: 10px; overflow: hidden;
      border: 1px solid rgba(255,255,255,0.04);
      background: #16213e;
    }
    .code-header {
      display: flex; align-items: center; justify-content: space-between;
      padding: 8px 14px;
      border-bottom: 1px solid rgba(255,255,255,0.04);
      user-select: none;
    }
    .code-header .code-label {
      display: inline-block; font-size: 0.65rem; font-weight: 600;
      color: #475569; text-transform: uppercase; letter-spacing: 0.08em;
      margin: 0;
    }
    .code-toolbar { display: flex; gap: 2px; }
    .code-toolbar button {
      background: none; border: none; cursor: pointer;
      color: #475569; font-size: 0.72rem; padding: 3px 8px;
      border-radius: 4px; transition: all 0.15s;
      font-family: inherit; display: inline-flex; align-items: center; gap: 4px;
    }
    .code-toolbar button:hover { color: #94a3b8; background: rgba(255,255,255,0.04); }
    .code-toolbar button.copied { color: #10b981; }

    /* ‚îÄ‚îÄ Code block ‚îÄ‚îÄ */
    .code-block {
      padding: 16px 14px;
      font-family: 'JetBrains Mono', 'Fira Code', monospace;
      font-size: 0.78rem; line-height: 1.8; color: #94a3b8;
      overflow-x: auto;
      white-space: pre;
      transition: max-height 0.3s ease, padding 0.3s ease, opacity 0.2s ease;
    }
    .code-block.collapsed {
      max-height: 0; padding-top: 0; padding-bottom: 0;
      opacity: 0; overflow: hidden;
    }
    .code-block .kw { color: #7c3aed; }
    .code-block .fn { color: #4cc9f0; }
    .code-block .str { color: #10b981; }
    .code-block .cm { color: #475569; }
    .code-block .tag { color: #f59e0b; }
    .code-block .attr { color: #4cc9f0; }
    .code-block .num { color: #f59e0b; }

    .code-alt {
      color: #475569; font-size: 0.75rem; margin-top: 8px; font-style: italic;
    }
    .code-alt code {
      background: rgba(255,255,255,0.04); padding: 2px 6px; border-radius: 4px;
      font-family: 'JetBrains Mono', monospace; font-size: 0.72rem;
      color: #64748b; font-style: normal;
    }

    /* ‚îÄ‚îÄ Callout card ‚îÄ‚îÄ */
    .callout {
      background: #16213e; border-radius: 10px; padding: 20px;
      border: 1px solid rgba(76,201,240,0.12);
      display: flex; align-items: center; gap: 16px;
    }
    .callout-icon { font-size: 2rem; flex-shrink: 0; }
    .callout h4 { font-size: 0.9rem; font-weight: 700; margin-bottom: 4px; }
    .callout p { font-size: 0.8rem; color: #64748b; }
    .callout a {
      display: inline-flex; align-items: center; gap: 4px;
      margin-top: 8px; color: #4cc9f0; text-decoration: none;
      font-size: 0.8rem; font-weight: 600;
    }
    .callout a:hover { text-decoration: underline; }

    /* ‚îÄ‚îÄ Unified Demo Panel ‚îÄ‚îÄ */
    .demo-panel {
      max-width: 820px; margin: 0 auto 40px; padding: 0 24px;
    }
    .demo-panel-header {
      display: flex; align-items: center; justify-content: space-between;
      padding: 12px 16px; background: #16213e;
      border: 1px solid rgba(76,201,240,0.15);
      border-bottom: none;
      border-radius: 12px 12px 0 0;
      font-size: 0.8rem; font-weight: 700; color: #e2e8f0;
      text-transform: uppercase; letter-spacing: 0.06em;
    }
    .demo-canvas-area {
      border-left: 1px solid rgba(76,201,240,0.15);
      border-right: 1px solid rgba(76,201,240,0.15);
    }
    .demo-canvas-area .canvas-wrap { border-radius: 0; }
    .demo-controls {
      background: #16213e; padding: 14px 16px;
      border: 1px solid rgba(76,201,240,0.15);
      border-top: 1px solid rgba(255,255,255,0.06);
      border-radius: 0 0 12px 12px;
    }
    .demo-controls-row {
      display: flex; align-items: center; gap: 8px; flex-wrap: wrap;
    }

    /* Step group inside demo controls */
    .demo-step-group { margin-bottom: 2px; }
    .demo-step-label {
      display: flex; align-items: center; gap: 6px;
      font-size: 0.65rem; font-weight: 700; text-transform: uppercase;
      letter-spacing: 0.06em; color: #475569;
      margin-bottom: 8px;
    }
    .demo-step-label .step-chip {
      display: inline-flex; align-items: center; justify-content: center;
      width: 20px; height: 20px; border-radius: 50%;
      font-size: 0.6rem; font-weight: 800;
      background: rgba(76,201,240,0.1); color: #4cc9f0;
      border: 1.5px solid rgba(76,201,240,0.25);
      flex-shrink: 0;
    }
    .demo-step-label .step-check {
      display: none;
      color: #10b981; font-size: 0.72rem; font-weight: 700;
    }
    .demo-step-group.done .step-chip {
      background: rgba(16,185,129,0.15); color: #10b981;
      border-color: rgba(16,185,129,0.3);
    }
    .demo-step-group.done .step-check { display: inline; }

    .demo-divider {
      height: 1px; background: rgba(255,255,255,0.04); margin: 10px 0;
    }
    .demo-separator {
      width: 1px; height: 24px; background: rgba(255,255,255,0.08);
      margin: 0 4px;
    }
    .demo-status {
      font-size: 0.72rem; color: #64748b; margin-top: 8px;
      min-height: 1em;
    }
    .demo-controls .btn { padding: 8px 16px; font-size: 0.78rem; }
    .btn-danger {
      background: rgba(239,68,68,0.12); color: #ef4444;
      border: 1px solid rgba(239,68,68,0.2);
    }
    .btn-danger:hover { background: rgba(239,68,68,0.2); }

    /* ‚îÄ‚îÄ Buttons ‚îÄ‚îÄ */
    .btn {
      display: inline-flex; align-items: center; gap: 8px;
      padding: 10px 20px; border-radius: 8px; border: none;
      font-size: 0.85rem; font-weight: 600; cursor: pointer;
      transition: all 0.15s; font-family: inherit;
    }
    .btn-primary {
      background: #4cc9f0; color: #0f0f1a;
    }
    .btn-primary:hover { background: #7dd8f5; }
    .btn-primary:disabled { opacity: 0.3; cursor: not-allowed; }

    .btn-secondary {
      background: rgba(76,201,240,0.08); color: #4cc9f0;
      border: 1px solid rgba(76,201,240,0.15);
    }
    .btn-secondary:hover { background: rgba(76,201,240,0.15); }
    .btn-secondary:disabled { opacity: 0.3; cursor: not-allowed; }
    .btn-secondary.active {
      border-color: #4cc9f0; background: rgba(76,201,240,0.15);
    }

    .btn-success { background: #10b981; color: #0f0f1a; }
    .btn-success:hover { background: #34d399; }

    /* ‚îÄ‚îÄ Progress bar ‚îÄ‚îÄ */
    .progress-bar {
      width: 100%; height: 6px; background: rgba(255,255,255,0.06);
      border-radius: 3px; overflow: hidden; margin-top: 12px;
    }
    .progress-bar-fill {
      height: 100%; width: 0%;
      background: linear-gradient(90deg, #4cc9f0, #10b981);
      transition: width 0.3s;
    }
    .progress-label {
      font-size: 0.72rem; color: #64748b; margin-top: 6px;
    }

    /* ‚îÄ‚îÄ Canvas area ‚îÄ‚îÄ */
    .canvas-wrap {
      position: relative; width: 100%; aspect-ratio: 16/10;
      background: #0f0f1a; border-radius: 8px; overflow: hidden;
    }
    .canvas-wrap canvas { width: 100%; height: 100%; display: block; }

    .drop-overlay {
      position: absolute; inset: 0;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      gap: 8px; font-size: 0.85rem; color: #475569;
      border: 2px dashed rgba(76,201,240,0.2); border-radius: 8px;
      transition: all 0.2s; cursor: pointer;
    }
    .drop-overlay:hover, .drop-overlay.dragover {
      border-color: #4cc9f0; background: rgba(76,201,240,0.04);
    }
    .drop-overlay.hidden { display: none; }
    .drop-overlay a { color: #4cc9f0; text-decoration: none; font-size: 0.8rem; }
    .drop-overlay a:hover { text-decoration: underline; }

    /* ‚îÄ‚îÄ Status badges ‚îÄ‚îÄ */
    .status-badge {
      display: inline-block; padding: 3px 10px; border-radius: 20px;
      font-size: 0.68rem; font-weight: 600;
    }
    .status-badge.waiting { background: rgba(100,100,100,0.15); color: #64748b; }
    .status-badge.ready { background: rgba(16,185,129,0.12); color: #10b981; }
    .status-badge.error { background: rgba(239,68,68,0.12); color: #ef4444; }

    /* ‚îÄ‚îÄ Footer ‚îÄ‚îÄ */
    footer {
      border-top: 1px solid rgba(255,255,255,0.04);
      padding: 20px 24px; text-align: center;
      font-size: 0.72rem; color: #334155;
    }
    footer a { color: #4cc9f0; text-decoration: none; }

    /* ‚îÄ‚îÄ Responsive ‚îÄ‚îÄ */
    @media (max-width: 640px) {
      .guide-header h1 { font-size: 1.5rem; }
      .step { grid-template-columns: 36px 1fr; gap: 0 16px; }
      .step-num { width: 36px; height: 36px; font-size: 0.9rem; }
      .step.completed .step-num::after { font-size: 1rem; }
      .step:not(:last-child)::before { left: 17px; top: 36px; }
      .timeline { padding: 24px 16px 40px; }
      .callout { flex-direction: column; text-align: center; }
    }
  </style>
</head>
<body>
<!--email_off-->

<!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ HEADER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div class="guide-header">
  <a href="../../" class="back-link">&larr; AnimaSync Home</a>
  <h1>Build Your Own AI <span>Talking Avatar</span></h1>
  <p class="lead">
    Download a VRM avatar, wire up AnimaSync V1, and make it talk ‚Äî all in 6 steps, entirely in the browser.
  </p>
  <div class="time-badge">~15 min &middot; V1 Engine &middot; No server required</div>
</div>

<!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ TIMELINE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div class="timeline">

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê STEP 1: Get a VRM Avatar ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <div class="step" id="step-1">
    <div class="step-num"><span>1</span></div>
    <div class="step-body">
      <h2 class="step-title">Get a VRM Avatar</h2>
      <p class="step-desc">
        VRM is an open standard for 3D humanoid avatars. You can download free models from
        <a href="https://hub.vroid.com/" target="_blank" rel="noopener noreferrer">VRoid Hub</a>.
        Here's how:
      </p>

      <!-- Recommended free model -->
      <div class="callout" style="margin-bottom:12px">
        <div class="callout-icon">üßë‚Äçüé§</div>
        <div>
          <h4>Recommended: Free Sample Model</h4>
          <p>This character is free to download with "Allow" characterization. Click the link, then press the <strong>"Download"</strong> button on the model page to get the <code>.vrm</code> file.</p>
          <a href="https://hub.vroid.com/en/characters/1245908975744054638" target="_blank" rel="noopener noreferrer">
            Download this VRM &rarr;
          </a>
        </div>
      </div>

      <!-- How to download -->
      <div class="callout">
        <div class="callout-icon">üì•</div>
        <div>
          <h4>How to Download from VRoid Hub</h4>
          <p>
            1. Visit a model page &rarr;
            2. Click <strong>"Download"</strong> (agree to terms) &rarr;
            3. Save the <code>.vrm</code> file &rarr;
            4. Drag it into the viewport in Step 4 below.
          </p>
          <a href="https://hub.vroid.com/en/models?characterization=allow" target="_blank" rel="noopener noreferrer">
            Browse more free VRMs &rarr;
          </a>
        </div>
      </div>
    </div>
  </div>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê STEP 2: Set Up the Project ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <div class="step" id="step-2">
    <div class="step-num"><span>2</span></div>
    <div class="step-body">
      <h2 class="step-title">Set Up the Project</h2>
      <p class="step-desc">
        Add the dependencies via a CDN import map ‚Äî no bundler needed. This loads Three.js for 3D rendering,
        <code>&#64;pixiv/three-vrm</code> for VRM support, ONNX Runtime for neural inference, and AnimaSync V1 for lip sync.
      </p>

      <div class="code-wrap">
        <div class="code-header">
          <span class="code-label">HTML &mdash; CDN Import Map</span>
          <div class="code-toolbar">
            <button data-action="copy">Copy</button>
            <button data-action="fold">Fold</button>
          </div>
        </div>
        <div class="code-block"><span class="tag">&lt;script </span><span class="attr">type</span>=<span class="str">"importmap"</span><span class="tag">&gt;</span>
{ <span class="str">"imports"</span>: {
  <span class="str">"three"</span>:            <span class="str">"https://cdn.jsdelivr.net/npm/three&#64;0.179.1/build/three.module.js"</span>,
  <span class="str">"three/addons/"</span>:    <span class="str">"https://cdn.jsdelivr.net/npm/three&#64;0.179.1/examples/jsm/"</span>,
  <span class="str">"&#64;pixiv/three-vrm"</span>: <span class="str">"https://cdn.jsdelivr.net/npm/&#64;pixiv/three-vrm&#64;3.4.5/...module.min.js"</span>
}}
<span class="tag">&lt;/script&gt;</span>

<span class="cm">&lt;!-- ONNX Runtime (required by AnimaSync) --&gt;</span>
<span class="tag">&lt;script </span><span class="attr">src</span>=<span class="str">"https://cdn.jsdelivr.net/npm/onnxruntime-web&#64;1.17.0/dist/ort.min.js"</span><span class="tag">&gt;&lt;/script&gt;</span></div>
      </div>

      <p class="code-alt">
        Or install via npm: <code>npm install three &#64;pixiv/three-vrm onnxruntime-web &#64;goodganglabs/lipsync-wasm-v1</code>
      </p>
    </div>
  </div>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê STEP 3: Initialize AnimaSync ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <div class="step" id="step-3">
    <div class="step-num"><span>3</span></div>
    <div class="step-body">
      <h2 class="step-title">Initialize AnimaSync</h2>
      <p class="step-desc">
        Create a <code>LipSyncWasmWrapper</code>, then call <code>init()</code>.
        This loads the Rust/WASM module, validates the license (30-day free trial with no signup), and decrypts the ONNX model.
      </p>

      <div class="code-wrap">
        <div class="code-header">
          <span class="code-label">JavaScript</span>
          <div class="code-toolbar">
            <button data-action="copy">Copy</button>
            <button data-action="fold">Fold</button>
          </div>
        </div>
        <div class="code-block"><span class="kw">const</span> CDN = <span class="str">'https://cdn.jsdelivr.net/npm/&#64;goodganglabs/lipsync-wasm-v1&#64;0.4.3'</span>;

<span class="kw">const</span> { <span class="fn">LipSyncWasmWrapper</span> } = <span class="kw">await</span> <span class="fn">import</span>(<span class="str">`${CDN}/lipsync-wasm-wrapper.js`</span>);
<span class="kw">const</span> lipsync = <span class="kw">new</span> <span class="fn">LipSyncWasmWrapper</span>({ <span class="attr">wasmPath</span>: <span class="str">`${CDN}/lipsync_wasm_v1.js`</span> });

<span class="kw">await</span> lipsync.<span class="fn">init</span>({
  <span class="fn">onProgress</span>: (stage, pct) =&gt; console.<span class="fn">log</span>(<span class="str">`${stage}: ${pct}%`</span>)
});
<span class="cm">// Stages: wasm ‚Üí license ‚Üí decrypt ‚Üí onnx</span></div>
      </div>

    </div>
  </div>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê STEP 4: Load VRM into Three.js ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <div class="step" id="step-4">
    <div class="step-num"><span>4</span></div>
    <div class="step-body">
      <h2 class="step-title">Load VRM into Three.js</h2>
      <p class="step-desc">
        Create a scene with a camera, orbit controls, and lighting. Then load the VRM using
        <code>GLTFLoader</code> with the <code>VRMLoaderPlugin</code>.
        AnimaSync also provides embedded VRMA bone animation clips for idle breathing and speaking gestures.
      </p>

      <div class="code-wrap">
        <div class="code-header">
          <span class="code-label">JavaScript &mdash; Scene + VRM Loading</span>
          <div class="code-toolbar">
            <button data-action="copy">Copy</button>
            <button data-action="fold">Fold</button>
          </div>
        </div>
        <div class="code-block"><span class="kw">import</span> * <span class="kw">as</span> THREE <span class="kw">from</span> <span class="str">'three'</span>;
<span class="kw">import</span> { <span class="fn">OrbitControls</span> } <span class="kw">from</span> <span class="str">'three/addons/controls/OrbitControls.js'</span>;
<span class="kw">import</span> { <span class="fn">GLTFLoader</span> } <span class="kw">from</span> <span class="str">'three/addons/loaders/GLTFLoader.js'</span>;
<span class="kw">import</span> { <span class="fn">VRMLoaderPlugin</span> } <span class="kw">from</span> <span class="str">'&#64;pixiv/three-vrm'</span>;

<span class="cm">// Scene</span>
<span class="kw">const</span> renderer = <span class="kw">new</span> THREE.<span class="fn">WebGLRenderer</span>({ canvas, antialias: <span class="num">true</span> });
<span class="kw">const</span> scene    = <span class="kw">new</span> THREE.<span class="fn">Scene</span>();
<span class="kw">const</span> camera   = <span class="kw">new</span> THREE.<span class="fn">PerspectiveCamera</span>(<span class="num">30</span>, w/h, <span class="num">0.1</span>, <span class="num">100</span>);
camera.position.<span class="fn">set</span>(<span class="num">0</span>, <span class="num">1.25</span>, <span class="num">1.5</span>);

<span class="cm">// Load VRM</span>
<span class="kw">const</span> loader = <span class="kw">new</span> <span class="fn">GLTFLoader</span>();
loader.<span class="fn">register</span>(p =&gt; <span class="kw">new</span> <span class="fn">VRMLoaderPlugin</span>(p));

<span class="kw">const</span> gltf = <span class="kw">await</span> loader.<span class="fn">loadAsync</span>(vrmUrl);
<span class="kw">const</span> vrm  = gltf.userData.vrm;
scene.<span class="fn">add</span>(vrm.scene);
vrm.scene.rotation.y = Math.PI;</div>
      </div>

    </div>
  </div>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê STEP 5: Apply Lip Sync ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <div class="step" id="step-5">
    <div class="step-num"><span>5</span></div>
    <div class="step-body">
      <h2 class="step-title">Apply Lip Sync</h2>
      <p class="step-desc">
        Process an audio file to get blendshape frames, then apply each frame's 52 ARKit values to the VRM
        <code>expressionManager</code> inside the render loop. AnimaSync outputs at 30 fps.
      </p>

      <div class="code-wrap">
        <div class="code-header">
          <span class="code-label">JavaScript &mdash; Process + Render Loop</span>
          <div class="code-toolbar">
            <button data-action="copy">Copy</button>
            <button data-action="fold">Fold</button>
          </div>
        </div>
        <div class="code-block"><span class="kw">const</span> ARKIT_52 = [<span class="str">'browDownLeft'</span>, <span class="str">'browDownRight'</span>, <span class="str">'browInnerUp'</span>, <span class="cm">/* ...49 more */</span>];

<span class="cm">// Process audio file</span>
<span class="kw">const</span> result = <span class="kw">await</span> lipsync.<span class="fn">processFile</span>(audioFile);

<span class="cm">// Queue all frames</span>
<span class="kw">const</span> queue = [];
<span class="kw">for</span> (<span class="kw">let</span> i = <span class="num">0</span>; i &lt; result.frame_count; i++)
  queue.<span class="fn">push</span>(lipsync.<span class="fn">getFrame</span>(result, i));

<span class="cm">// Apply inside render loop at 30fps</span>
<span class="kw">function</span> <span class="fn">render</span>() {
  requestAnimationFrame(render);
  <span class="kw">if</span> (queue.length &gt; <span class="num">0</span>) {
    <span class="kw">const</span> frame = queue.<span class="fn">shift</span>();
    <span class="kw">for</span> (<span class="kw">let</span> i = <span class="num">0</span>; i &lt; <span class="num">52</span>; i++)
      vrm.expressionManager.<span class="fn">setValue</span>(ARKIT_52[i], frame[i]);
  }
  vrm.<span class="fn">update</span>(dt);
  renderer.<span class="fn">render</span>(scene, camera);
}</div>
      </div>

    </div>
  </div>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê STEP 6: Complete ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <div class="step" id="step-6">
    <div class="step-num"><span>6</span></div>
    <div class="step-body">
      <h2 class="step-title">Add Real-time Microphone</h2>
      <p class="step-desc">
        For real-time lip sync, capture microphone audio with an <code>AudioWorklet</code> at 16 kHz,
        then feed 100 ms chunks to <code>processAudioChunk()</code>. Pipeline latency is ~130-300 ms.
      </p>

      <div class="code-wrap">
        <div class="code-header">
          <span class="code-label">JavaScript &mdash; Mic Streaming</span>
          <div class="code-toolbar">
            <button data-action="copy">Copy</button>
            <button data-action="fold">Fold</button>
          </div>
        </div>
        <div class="code-block"><span class="kw">const</span> stream = <span class="kw">await</span> navigator.mediaDevices.<span class="fn">getUserMedia</span>({ audio: <span class="num">true</span> });
<span class="kw">const</span> ctx    = <span class="kw">new</span> <span class="fn">AudioContext</span>({ sampleRate: <span class="num">16000</span> });
<span class="kw">const</span> source = ctx.<span class="fn">createMediaStreamSource</span>(stream);

<span class="cm">// AudioWorklet captures 1600 samples (100ms at 16kHz)</span>
worklet.port.onmessage = <span class="kw">async</span> (e) =&gt; {
  <span class="kw">const</span> result = <span class="kw">await</span> lipsync.<span class="fn">processAudioChunk</span>(e.data);
  <span class="kw">if</span> (result)
    <span class="kw">for</span> (<span class="kw">let</span> i = <span class="num">0</span>; i &lt; result.frame_count; i++)
      queue.<span class="fn">push</span>(lipsync.<span class="fn">getFrame</span>(result, i));
};</div>
      </div>

    </div>
  </div>

</div><!-- /timeline -->

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
     UNIFIED LIVE DEMO PANEL
     ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="demo-panel" id="demo-panel">
  <div class="demo-panel-header">
    <span>Live Demo</span>
    <div style="display:flex;align-items:center;gap:8px">
      <span class="status-badge waiting" id="init-badge">Not initialized</span>
      <span class="status-badge waiting" id="vrm-badge" style="display:none"></span>
    </div>
  </div>

  <!-- Canvas -->
  <div class="demo-canvas-area">
    <div class="canvas-wrap" id="canvas-wrap">
      <canvas id="avatar-canvas"></canvas>
      <div class="drop-overlay" id="vrm-drop">
        <span style="font-size:1.8rem">üì¶</span>
        <span>Drop a <strong>.vrm</strong> file here or use the button below</span>
        <a href="https://hub.vroid.com/en/characters/1245908975744054638" target="_blank" rel="noopener noreferrer">
          Download a free VRM &rarr;
        </a>
      </div>
    </div>
  </div>

  <!-- Controls -->
  <div class="demo-controls">
    <!-- Step 3: Init -->
    <div class="demo-step-group" id="demo-group-3">
      <div class="demo-step-label">
        <span class="step-chip">3</span> Initialize Engine <span class="step-check">‚úì</span>
      </div>
      <div class="demo-controls-row">
        <button class="btn btn-primary" id="btn-init">Initialize V1 Engine</button>
      </div>
      <div class="progress-bar" id="init-progress" style="display:none">
        <div class="progress-bar-fill" id="init-progress-fill"></div>
      </div>
      <div class="progress-label" id="init-progress-label" style="display:none"></div>
    </div>

    <div class="demo-divider"></div>

    <!-- Step 4: VRM -->
    <div class="demo-step-group" id="demo-group-4">
      <div class="demo-step-label">
        <span class="step-chip">4</span> Load VRM Avatar <span class="step-check">‚úì</span>
      </div>
      <div class="demo-controls-row">
        <button class="btn btn-secondary" id="btn-vrm">Upload VRM</button>
        <input type="file" id="vrm-input" accept=".vrm" style="display:none">
      </div>
    </div>

    <div class="demo-divider"></div>

    <!-- Step 5: Audio -->
    <div class="demo-step-group" id="demo-group-5">
      <div class="demo-step-label">
        <span class="step-chip">5</span> Audio Lip Sync <span class="step-check">‚úì</span>
      </div>
      <div class="demo-controls-row">
        <button class="btn btn-secondary" id="btn-audio" disabled>Upload Audio</button>
        <input type="file" id="audio-input" accept="audio/*" style="display:none">
        <button class="btn btn-secondary" id="btn-audio-stop" disabled style="display:none">Stop</button>
      </div>
    </div>

    <div class="demo-divider"></div>

    <!-- Step 6: Mic -->
    <div class="demo-step-group" id="demo-group-6">
      <div class="demo-step-label">
        <span class="step-chip">6</span> Microphone Streaming <span class="step-check">‚úì</span>
      </div>
      <div class="demo-controls-row">
        <button class="btn btn-secondary" id="btn-mic" disabled>Start Mic</button>
      </div>
    </div>

    <!-- Status line -->
    <div class="demo-status" id="demo-status"></div>
  </div>
</div>

<footer>
  <a href="../../">AnimaSync</a> &mdash; Built by <a href="https://goodganglabs.com" target="_blank" rel="noopener noreferrer">GoodGang Labs</a>
</footer>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
     SCRIPT ‚Äî Interactive sandbox logic
     ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<script type="module">
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Code block toolbar: Copy + Fold
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
document.querySelectorAll('.code-toolbar button').forEach(btn => {
  btn.addEventListener('click', () => {
    const wrap = btn.closest('.code-wrap');
    const block = wrap.querySelector('.code-block');
    if (btn.dataset.action === 'copy') {
      navigator.clipboard.writeText(block.textContent).then(() => {
        btn.textContent = 'Copied!'; btn.classList.add('copied');
        setTimeout(() => { btn.textContent = 'Copy'; btn.classList.remove('copied'); }, 1500);
      });
    }
    if (btn.dataset.action === 'fold') {
      const collapsed = block.classList.toggle('collapsed');
      btn.textContent = collapsed ? 'Expand' : 'Fold';
    }
  });
});

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Auto-complete read-only steps when scrolled into view
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const readOnlySteps = [document.getElementById('step-1'), document.getElementById('step-2')];
const stepObserver = new IntersectionObserver(entries => {
  entries.forEach(e => {
    if (e.isIntersecting) {
      e.target.classList.add('completed');
      stepObserver.unobserve(e.target);
    }
  });
}, { threshold: 0.6 });
readOnlySteps.forEach(el => { if (el) stepObserver.observe(el); });

import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { VRMLoaderPlugin } from '@pixiv/three-vrm';
import { VRMAnimationLoaderPlugin, createVRMAnimationClip } from '@pixiv/three-vrm-animation';

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Config
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const VERSION = '0.4.3';
const CDN = `https://cdn.jsdelivr.net/npm/@goodganglabs/lipsync-wasm-v1@${VERSION}`;
const ARKIT_52 = [
  'browDownLeft','browDownRight','browInnerUp','browOuterUpLeft','browOuterUpRight',
  'cheekPuff','cheekSquintLeft','cheekSquintRight',
  'eyeBlinkLeft','eyeBlinkRight','eyeLookDownLeft','eyeLookDownRight',
  'eyeLookInLeft','eyeLookInRight','eyeLookOutLeft','eyeLookOutRight',
  'eyeLookUpLeft','eyeLookUpRight','eyeSquintLeft','eyeSquintRight',
  'eyeWideLeft','eyeWideRight',
  'jawForward','jawLeft','jawOpen','jawRight',
  'mouthClose','mouthDimpleLeft','mouthDimpleRight','mouthFrownLeft','mouthFrownRight',
  'mouthFunnel','mouthLeft','mouthLowerDownLeft','mouthLowerDownRight',
  'mouthPressLeft','mouthPressRight','mouthPucker','mouthRight',
  'mouthRollLower','mouthRollUpper','mouthShrugLower','mouthShrugUpper',
  'mouthSmileLeft','mouthSmileRight','mouthStretchLeft','mouthStretchRight',
  'mouthUpperUpLeft','mouthUpperUpRight',
  'noseSneerLeft','noseSneerRight','tongueOut',
];

// VRM 18-dim expression names (matches vrm_convert.rs in WASM)
const VRM_EXPRESSIONS = [
  'aa','ih','ou','ee','oh',
  'happy','angry','sad','relaxed','surprised',
  'blink','blinkLeft','blinkRight',
  'lookUp','lookDown','lookLeft','lookRight',
  'neutral',
];


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// State
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let lipsync = null, vrm = null, mixer = null;
let idleAction = null, speakingAction = null;
let isSpeaking = false, crossFadeProgress = 0;
const frameQueue = [];  // mic streaming only
let fileAudioCtx = null, fileAudioSrc = null;
let fileResult = null, fileStartTime = 0, filePlaying = false;  // time-synced file playback
let micActive = false, micAudioCtx = null, micWorklet = null, micStream = null;
let useVrmMode = false;
let idleGenerator = null, idleClock = 0;
let prevFrame = null;

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// DOM refs
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const $ = id => document.getElementById(id);
const btnInit      = $('btn-init');
const initBadge    = $('init-badge');
const initProgress = $('init-progress');
const initFill     = $('init-progress-fill');
const initLabel    = $('init-progress-label');
const vrmBadge     = $('vrm-badge');
const vrmDrop      = $('vrm-drop');
const vrmInput     = $('vrm-input');
const btnVrm       = $('btn-vrm');
const btnAudio     = $('btn-audio');
const audioInput   = $('audio-input');
const btnAudioStop = $('btn-audio-stop');
const btnMic       = $('btn-mic');
const demoStatus   = $('demo-status');

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Three.js Scene
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const canvas = $('avatar-canvas');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.outputColorSpace = THREE.SRGBColorSpace;
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0f0f1a);
const camera = new THREE.PerspectiveCamera(30, 1, 0.1, 100);
camera.position.set(0, 1.25, 1.5);
const controls = new OrbitControls(camera, canvas);
controls.target.set(0, 1.25, 0);
controls.enableDamping = true;
controls.update();
scene.add(new THREE.DirectionalLight(0xffffff, 1.0));
scene.add(new THREE.AmbientLight(0xffffff, 0.6));

function resizeCanvas() {
  const wrap = $('canvas-wrap');
  const w = wrap.clientWidth, h = wrap.clientHeight;
  if (w > 0 && h > 0) { renderer.setSize(w, h); camera.aspect = w / h; camera.updateProjectionMatrix(); }
}
new ResizeObserver(resizeCanvas).observe($('canvas-wrap'));
resizeCanvas();

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// GLTFLoader
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const gltfLoader = new GLTFLoader();
gltfLoader.register(p => new VRMLoaderPlugin(p));
gltfLoader.register(p => new VRMAnimationLoaderPlugin(p));

async function loadVRMAFromBytes(bytes) {
  const blob = new Blob([bytes], { type: 'application/octet-stream' });
  const url = URL.createObjectURL(blob);
  const gltf = await gltfLoader.loadAsync(url);
  URL.revokeObjectURL(url);
  return gltf.userData.vrmAnimations?.[0] || null;
}

async function loadVRM(fileUrl) {
  if (vrm) scene.remove(vrm.scene);
  const gltf = await gltfLoader.loadAsync(fileUrl);
  vrm = gltf.userData.vrm;
  scene.add(vrm.scene);
  vrm.scene.rotation.y = Math.PI;
  mixer = new THREE.AnimationMixer(vrm.scene);
  idleAction = null; speakingAction = null;

  if (lipsync?.ready) {
    try {
      const vrmaBytes = lipsync.getVrmaBytes();
      if (vrmaBytes?.idle?.length) {
        const a = await loadVRMAFromBytes(vrmaBytes.idle);
        if (a) { idleAction = mixer.clipAction(createVRMAnimationClip(a, vrm)); idleAction.play(); }
      }
      if (vrmaBytes?.speaking?.length) {
        const a = await loadVRMAFromBytes(vrmaBytes.speaking);
        if (a) { speakingAction = mixer.clipAction(createVRMAnimationClip(a, vrm)); speakingAction.play(); speakingAction.setEffectiveWeight(0); }
      }
    } catch (e) { console.warn('VRMA skip:', e.message); }
  }

  // Auto-detect VRM expression mode (ARKit 52-dim vs VRM 18-dim)
  useVrmMode = false;
  if (vrm.expressionManager) {
    const exprNames = Object.keys(vrm.expressionManager.expressionMap || {});
    const arkitNames = ['jawOpen','mouthFunnel','mouthPucker','eyeBlinkLeft','eyeBlinkRight'];
    const hasArkit = arkitNames.filter(n => exprNames.includes(n)).length >= 3;
    const vrmPresetNames = ['aa','ih','ou','ee','oh','happy','angry','sad','relaxed','surprised'];
    const hasVrmPreset = vrmPresetNames.filter(n => exprNames.includes(n)).length >= 3;
    if (!hasArkit && hasVrmPreset) useVrmMode = true;
    console.log(`[VRM] Mode: ${useVrmMode ? 'VRM 18-dim' : 'ARKit 52-dim'} (arkit=${hasArkit}, vrm=${hasVrmPreset})`);
  }

  vrmBadge.textContent = `VRM loaded (${useVrmMode ? 'VRM' : 'ARKit'})`;
  vrmBadge.className = 'status-badge ready';
  vrmBadge.style.display = '';
  vrmDrop.classList.add('hidden');
  setStatus('VRM loaded. Ready to animate.');
  completeStep(4);
  updateControls();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Initialize AnimaSync
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
btnInit.addEventListener('click', async () => {
  if (lipsync?.ready) return;
  btnInit.disabled = true;
  btnInit.textContent = 'Initializing...';
  initProgress.style.display = '';
  initLabel.style.display = '';

  try {
    const { LipSyncWasmWrapper } = await import(`${CDN}/lipsync-wasm-wrapper.js`);
    lipsync = new LipSyncWasmWrapper({ wasmPath: `${CDN}/lipsync_wasm_v1.js` });
    await lipsync.init({
      onProgress: (stage, pct) => { initFill.style.width = pct + '%'; initLabel.textContent = `${stage} ‚Äî ${pct}%`; },
    });

    // Initialize idle expression generator (eye blink + micro expressions)
    try {
      idleGenerator = new lipsync.wasmModule.IdleExpressionGenerator();
      idleClock = 0;
    } catch (e) { console.warn('Idle generator init failed:', e); }

    initBadge.textContent = 'V1 Ready';
    initBadge.className = 'status-badge ready';
    btnInit.textContent = 'Initialized';
    initProgress.style.display = 'none';
    initLabel.style.display = 'none';
    completeStep(3);
    setStatus('Engine ready. Upload a VRM to continue.');
    updateControls();
  } catch (err) {
    lipsync = null;
    initBadge.textContent = 'Error';
    initBadge.className = 'status-badge error';
    btnInit.textContent = 'Retry';
    btnInit.disabled = false;
    initLabel.textContent = err.message;
    console.error('Init error:', err);
  }
});

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// VRM Upload (button + drop + drag)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
async function handleVRMFile(file) {
  if (!file?.name.endsWith('.vrm')) return;
  if (file.size > 100 * 1024 * 1024) { setStatus('Error: VRM exceeds 100 MB'); return; }
  vrmBadge.textContent = 'Loading...';
  vrmBadge.className = 'status-badge waiting';
  vrmBadge.style.display = '';
  setStatus('Loading VRM...');
  const url = URL.createObjectURL(file);
  try { await loadVRM(url); } catch (e) {
    setStatus('Error loading VRM: ' + e.message);
    vrmBadge.textContent = 'Error'; vrmBadge.className = 'status-badge error';
  } finally { URL.revokeObjectURL(url); }
}

btnVrm.addEventListener('click', () => vrmInput.click());
vrmInput.addEventListener('change', e => { if (e.target.files[0]) handleVRMFile(e.target.files[0]); });
vrmDrop.addEventListener('click', e => { if (e.target.tagName === 'A') return; vrmInput.click(); });

const canvasWrap = $('canvas-wrap');
canvasWrap.addEventListener('dragover', e => { e.preventDefault(); vrmDrop.classList.add('dragover'); });
canvasWrap.addEventListener('dragleave', () => vrmDrop.classList.remove('dragover'));
canvasWrap.addEventListener('drop', e => {
  e.preventDefault(); vrmDrop.classList.remove('dragover');
  const file = [...e.dataTransfer.files].find(f => f.name.endsWith('.vrm'));
  if (file) handleVRMFile(file);
});

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Audio File
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
btnAudio.addEventListener('click', () => audioInput.click());
audioInput.addEventListener('change', e => { if (e.target.files[0]) processAudioFile(e.target.files[0]); });

btnAudioStop.addEventListener('click', stopAudio);

function stopAudio() {
  filePlaying = false;
  fileResult = null;
  if (fileAudioSrc) { try { fileAudioSrc.stop(); } catch {} fileAudioSrc = null; }
  if (fileAudioCtx) { fileAudioCtx.close(); fileAudioCtx = null; }
  frameQueue.length = 0;
  transitionToIdle();
  resetVRM();
  if (idleGenerator) { idleGenerator.reset(); idleClock = 0; }
  btnAudioStop.style.display = 'none';
  btnAudioStop.disabled = true;
  setStatus('Audio stopped.');
}

async function processAudioFile(file) {
  if (!lipsync?.ready || !vrm) return;
  stopAudio(); // stop any previous playback
  setStatus('Processing audio...');

  try {
    const result = await lipsync.processFile(file);

    // Decode audio first, then start both at the same time
    fileAudioCtx = new AudioContext();
    const buf = await file.arrayBuffer();
    const audioBuf = await fileAudioCtx.decodeAudioData(buf);
    fileAudioSrc = fileAudioCtx.createBufferSource();
    fileAudioSrc.buffer = audioBuf;
    fileAudioSrc.connect(fileAudioCtx.destination);

    // Store result for time-synced frame lookup in render loop
    fileResult = result;
    fileStartTime = fileAudioCtx.currentTime;
    filePlaying = true;
    prevFrame = null;

    fileAudioSrc.start();
    transitionToSpeaking();
    fileAudioSrc.onended = () => { stopAudio(); setStatus('Playback finished.'); };

    btnAudioStop.style.display = '';
    btnAudioStop.disabled = false;
    setStatus(`Playing ‚Äî ${result.frame_count} frames @ 30 fps`);
    completeStep(5);
  } catch (err) {
    setStatus('Audio error: ' + err.message);
    console.error('Audio error:', err);
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Microphone Streaming
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
btnMic.addEventListener('click', async () => {
  if (micActive) { stopMic(); return; }
  if (!lipsync?.ready || !vrm) return;
  stopAudio(); // stop file playback if any

  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    micStream = stream;
    micAudioCtx = new AudioContext({ sampleRate: 16000 });
    const source = micAudioCtx.createMediaStreamSource(stream);

    const code = `class P extends AudioWorkletProcessor{constructor(){super();this._b=[];}process(i){const c=i[0]?.[0];if(c){for(let j=0;j<c.length;j++)this._b.push(c[j]);if(this._b.length>=1600){this.port.postMessage(new Float32Array(this._b.splice(0,1600)));}}return true;}}registerProcessor('pcm-cap-guide',P);`;
    const blob = new Blob([code], { type: 'application/javascript' });
    const burl = URL.createObjectURL(blob);
    await micAudioCtx.audioWorklet.addModule(burl);
    URL.revokeObjectURL(burl);

    micWorklet = new AudioWorkletNode(micAudioCtx, 'pcm-cap-guide');
    source.connect(micWorklet);
    transitionToSpeaking();

    micWorklet.port.onmessage = async e => {
      const result = await lipsync.processAudioChunk(e.data);
      if (result) for (let i = 0; i < result.frame_count; i++) {
        frameQueue.push({ arkit: lipsync.getFrame(result, i), vrm: lipsync.getVrmFrame(result, i) });
      }
    };

    micActive = true;
    btnMic.textContent = 'Stop Mic';
    btnMic.classList.add('active');
    setStatus('Microphone streaming ‚Äî speak now...');
    completeStep(6);
  } catch (err) {
    setStatus('Mic error: ' + err.message);
    console.error('Mic error:', err);
  }
});

function stopMic() {
  if (micWorklet) { micWorklet.disconnect(); micWorklet = null; }
  if (micAudioCtx) { micAudioCtx.close(); micAudioCtx = null; }
  if (micStream) { micStream.getTracks().forEach(t => t.stop()); micStream = null; }
  micActive = false;
  btnMic.textContent = 'Start Mic';
  btnMic.classList.remove('active');
  transitionToIdle();
  if (lipsync) lipsync.reset();
  if (idleGenerator) { idleGenerator.reset(); idleClock = 0; }
  setStatus('Microphone stopped.');
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Helpers
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function applyArkitBlendshapes(frame) {
  if (!vrm?.expressionManager) return;
  for (let i = 0; i < Math.min(frame.length, ARKIT_52.length); i++) vrm.expressionManager.setValue(ARKIT_52[i], frame[i]);
}
function applyVrmBlendshapes(vrmFrame) {
  if (!vrm?.expressionManager || !vrmFrame) return;
  for (let i = 0; i < VRM_EXPRESSIONS.length; i++) {
    vrm.expressionManager.setValue(VRM_EXPRESSIONS[i], vrmFrame[i] || 0);
  }
}
function applyFrame(arkitFrame, vrmFrame) {
  if (useVrmMode) applyVrmBlendshapes(vrmFrame);
  else applyArkitBlendshapes(arkitFrame);
  prevFrame = arkitFrame;
}
function resetVRM() {
  if (!vrm?.expressionManager) return;
  const names = useVrmMode ? VRM_EXPRESSIONS : ARKIT_52;
  for (const n of names) vrm.expressionManager.setValue(n, 0);
  prevFrame = null;
}
function transitionToSpeaking() { isSpeaking = true; crossFadeProgress = 1; }
function transitionToIdle() { isSpeaking = false; }
function updateBoneWeights(dt) {
  const speed = 3.0;
  if (isSpeaking && crossFadeProgress < 1) crossFadeProgress = Math.min(1, crossFadeProgress + dt * speed);
  else if (!isSpeaking && crossFadeProgress > 0) crossFadeProgress = Math.max(0, crossFadeProgress - dt * speed);
  const w = crossFadeProgress * crossFadeProgress * (3 - 2 * crossFadeProgress);
  if (idleAction) idleAction.setEffectiveWeight(1 - w);
  if (speakingAction) speakingAction.setEffectiveWeight(w);
}

function setStatus(msg) { demoStatus.textContent = msg; }

function completeStep(n) {
  const el = document.getElementById('step-' + n);
  if (el && !el.classList.contains('completed')) el.classList.add('completed');
  const group = document.getElementById('demo-group-' + n);
  if (group && !group.classList.contains('done')) group.classList.add('done');
}

function updateControls() {
  const ready = lipsync?.ready;
  const loaded = !!vrm;
  const canAnimate = ready && loaded;
  btnAudio.disabled = !canAnimate;
  btnMic.disabled = !canAnimate;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Render Loop
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const clock = new THREE.Clock();
let streamTimer = 0;
const FRAME_INTERVAL = 1 / 30;

function render() {
  requestAnimationFrame(render);
  const dt = clock.getDelta();

  // 1a) File playback: time-synced frame lookup (audio-locked, no drift)
  if (filePlaying && fileResult && fileAudioCtx) {
    const elapsed = fileAudioCtx.currentTime - fileStartTime;
    const fps = fileResult.fps || 30;
    const frameIndex = Math.min(Math.floor(elapsed * fps), fileResult.frame_count - 1);
    if (frameIndex >= 0) {
      applyFrame(lipsync.getFrame(fileResult, frameIndex), lipsync.getVrmFrame(fileResult, frameIndex));
    }
  }
  // 1b) Mic streaming: queue-based at 30fps with drift correction
  else if (frameQueue.length > 0) {
    streamTimer += Math.min(dt, FRAME_INTERVAL * 2); // cap to prevent spike jumps
    while (streamTimer >= FRAME_INTERVAL && frameQueue.length > 0) {
      streamTimer -= FRAME_INTERVAL;
      const item = frameQueue.shift();
      applyFrame(item.arkit, item.vrm);
    }
  } else {
    streamTimer = 0;
  }

  // 2) Idle expression (eye blink + micro expressions) when not animating
  if (!micActive && !filePlaying && frameQueue.length === 0 && idleGenerator && vrm) {
    idleClock += dt;
    const rawIdle = idleGenerator.get_frame(idleClock);
    let idleFrame = rawIdle;

    // Smooth transition from last lip-sync frame to idle
    if (prevFrame) {
      const alpha = 0.15;
      idleFrame = new Array(rawIdle.length);
      let maxDiff = 0;
      for (let i = 0; i < rawIdle.length; i++) {
        idleFrame[i] = prevFrame[i] + alpha * ((rawIdle[i] || 0) - prevFrame[i]);
        const d = Math.abs(idleFrame[i] - (rawIdle[i] || 0));
        if (d > maxDiff) maxDiff = d;
      }
      prevFrame = idleFrame;
      if (maxDiff < 0.005) prevFrame = null; // converged
    }

    if (useVrmMode && lipsync?.wasmModule?.convert_arkit_to_vrm) {
      applyVrmBlendshapes(lipsync.wasmModule.convert_arkit_to_vrm(idleFrame));
    } else {
      applyArkitBlendshapes(idleFrame);
    }
  }

  // 3) Bone weights, VRM update, render
  updateBoneWeights(dt);
  if (vrm) vrm.update(dt);
  if (mixer) mixer.update(dt);
  controls.update();
  renderer.render(scene, camera);
}
render();
</script>
<!--email_on-->
</body>
</html>
